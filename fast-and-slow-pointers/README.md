# Fast and Slow Pointers

The **fast and slow pointers** pattern is a common technique used in algorithms to solve problems involving lists, cycles, and other data structures. It works by using two pointers that move through the data structure at different speeds. This difference in speed allows you to uncover information about the structure of the data, such as whether a linked list has a cycle.

## How It Works

The core idea is to have two pointers, a "slow" pointer and a "fast" pointer:

-   **Slow Pointer:** Moves one step at a time.
-   **Fast Pointer:** Moves two steps at a time.

This relative speed difference is the key to the pattern.

## Common Applications

This pattern is particularly useful for:

1.  **Cycle Detection in a Linked List:** If a linked list has a cycle, the fast pointer will eventually catch up to the slow pointer. If the fast pointer reaches the end of the list, there is no cycle.
2.  **Finding the Middle of a Linked List:** When the fast pointer reaches the end of the linked list, the slow pointer will be at the middle.
3.  **Happy Number Problem:** The sequence of numbers generated by summing the squares of digits can be treated as a linked list. If there is a cycle, the number is not a happy number.
4.  **Finding the Duplicate Number:** In an array where numbers are in a certain range, you can treat the array as a linked list and use cycle detection to find a duplicate number.

## Time and Space Complexity

-   **Time Complexity:** The time complexity is typically **O(N)**, where N is the number of elements in the data structure. This is because, in the worst case, each element is visited a constant number of times by the slow and fast pointers.
-   **Space Complexity:** The space complexity is **O(1)** because the algorithm only uses a constant amount of extra space for the two pointers.